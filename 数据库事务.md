---
title: 数据库事务
date: 2023-11-11 18:16:05
tags: [数据库, 事务]
---

## 什么是数据库事务以及为什么需要事务

事务（Transaction）是指数据库管理系统执行的一个或一组操作单元，这些操作要么全部执行成功，要么全部不执行，即事务具有原子性（Atomicity）。事务是确保数据一致性和完整性的一种机制。

数据库事务是指数据库系统中执行的一系列相关的操作，这些操作被视为一个逻辑单元，要么全部执行成功，要么全部执行失败，没有中间状态。数据库事务通常涉及对数据库中的数据进行读写操作，例如插入、更新、删除等。

数据库事务的存在是为了确保数据的一致性、完整性和可靠性。

### 数据库事务的特性（ACID）

数据库事务具有以下四个特性，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），通常称为事务的 ACID 特性。

* 原子性（Atomicity）：事务是一个不可分割的工作单元，要么全部执行成功，要么全部不执行。如果事务的任何部分操作失败，整个事务将被回滚，恢复到最初的状态。请注意，原子性并不意味着一个事务的操作无法被另一个事务打断，在并发环境下，多个事务可能会交错执行，调度器会根据具体的并发控制协议来决定事务的执行顺序。然而即使被打断，仍然会保证最终全部执行成功或者全部被回滚。

* 一致性（Consistency）：事务在执行前后，数据库的状态应保持一致。事务必须使数据库从一个一致性状态变换到另一个一致性状态。

* 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离性确保在并发执行的多个事务之间，每个事务看到的数据是独立的，互不干扰，防止并发执行事务时出现一些意外的、不一致的结果。数据库系统通过实现不同的隔离级别来控制事务之间的可见性，从而提供不同程度的隔离性。

* 持久性（Durability）：事务一旦提交，对数据库的修改就是永久性的，即使系统故障也不应该对其有任何影响，持久性确保数据的可靠性和长期保存。

<!-- more -->

### 事务的隔离级别

隔离性定义了在并发事务之间对数据的可见性（即一个事务的更新数据对另一个事务的可见性），数据库锁就是为了构建这些隔离级别存在的。数据库系统通过实现不同的隔离级别来控制事务之间的可见性，从而提供不同程度的隔离性。隔离级别越高，事务之间的隔离程度越高，但是并发性越低，系统的开销越大。

数据库系统通常实现了以下四种隔离级别：

* 读未提交（Read Uncommitted）：事务中的修改，即使没有提交，对其他事务也是可见的。最低的隔离级别。在这个级别，一个事务可以看到其他事务未提交的修改。

* 读提交（Read Committed）：事务提交后，它的修改才会对其他事务可见。这是大多数数据库系统的默认隔离级别。在这个级别，一个事务只能看到其他事务已提交的修改。

* 可重复读（Repeatable Read）：一个事务在多次执行同一查询时，同一查询将返回相同的结果，即使其他事务对数据进行了修改并提交。

* 串行化（Serializable）：最高级别的隔离，确保事务之间的完全隔离，事务串行化执行。读数据会加上共享锁，读写会相互阻塞，不允许并发执行，可能会产生大量的超时现象和锁竞争。

需要特别注意的是，不同的数据库系统对隔离级别的实现可能不同，对于同一隔离级别，其具体的实现细节也略微有不同，也会展现不同的具体特征。

### 并发事务带来的问题

事务的隔离级别定义了并发事务之间对数据的可见性同时，也带来了一些问题：

* 脏读（Dirty Read）：一个事务读取了另一个事务未提交的数据，如果另一个事务回滚，则读取到的数据是无效的。假设有两个并发事务T1和T2，T1读取了T2未提交的数据，如果T2回滚，则T1读取到的数据是无效的，这种现象称为脏读。

* 不可重复读（Non-Repeatable Read）：一个事务内多次读取同一数据，但在两次读取之间，另一个事务修改了数据并提交，导致两次读取的结果不一致。假设有两个并发事务T1和T2。T1读取了一条数据，然后T2修改了这条数据并提交。此时，如果T1再次读取这条数据，就会发现数据已经被改变。这就是不可重复读。

* 幻读（Phantom Read）：一个事务内多次执行同一个查询，但在两次查询之间，另一个事务插入了符合该查询条件的新数据，导致两次查询的结果不一致。假设有两个并发事务T1和T2。T1读取了一批数据，然后T2插入了一些数据。此时，如果T1再次读取相同的数据，就会发现有些数据是之前没有的，这就是幻读。**注意幻读和不可重复读的区别：不可重复读针对的是修改，幻读针对的是新增或删除。**

* 丢失更新（Lost Update）：两个事务同时读取同一数据，然后同时修改该数据并提交，导致其中一个事务的修改被覆盖。假设有两个并发事务T1和T2。T1、T2读取同一条数据，随后T1修改了这条数据并提交，然后T2也修改了这条数据并提交。这时，T1的修改被覆盖了，这就是丢失更新。

### 不同隔离级别下并发事务可能出现的问题

| 隔离级别 | 脏读（Dirty Read） | 不可重复读（Non-Repeatable Read） | 幻读（Phantom Read） | 丢失更新（Lost Update） |
| :---: | :---: | :---: | :---: | :---: |
| 读未提交（Read Uncommitted） | Possible | Possible | Possible | Possible |
| 读提交（Read Committed） | Not Possible | Possible | Possible | Possible |
| 可重复读（Repeatable Read） | Not Possible | Not Possible | Possible | Possible |
| 串行化（Serializable） | Not Possible | Not Possible | Not Possible | Not Possible |

**需要特别注意的是，以上表格中的可能出现的问题并不绝对，部分数据库的同一隔离级别实现仍有不同，因此并不会出现对应的问题。**例如在ANSI SQL STANDARD的标准定义中（如下图所示），在可重读隔离级别下是允许出现幻读，但是PGSQL的可重读隔离级别下，却不会出现幻读：

![ANSI SQL STANDARD](/images/ANSI_SQL_STANDARD.jpg)

### 悲观锁与乐观锁

当多个并发事务在某一隔离级别下同时操纵同一数据时，如果不加以控制，就可能会出现上述的问题。为了解决这些问题，数据库系统提供了两种不同的并发控制机制，分别是悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）。

#### 悲观锁

悲观锁是一种并发控制策略，它基于对数据的悲观估计，认为在事务执行期间其他事务可能会对同一数据进行修改。为了防止这种情况，悲观锁在事务访问数据时会对其进行加锁，以限制其他事务的并发访问，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（只有数据库层提供的锁机制才能真正保证数据访问的排他性，应用层面的加锁机制是无法保证外部系统无法修改数据）。

悲观锁一般分为如下几类：

* 共享锁（Shared Lock）：又称为读锁，允许事务读取一行数据，阻止其他事务获得相同数据集的排他锁，但是允许其他事务获得相同数据集的共享锁，即可以查看但无法修改和删除的一种数据锁，适用于读多写少的场景。

* 排他锁（Exclusive Lock）：又称为写锁，允许事务读取和修改一行数据，阻止其他事务获得相同数据集的共享锁和排他锁（即其他事务无法读取和修改），因此排他锁又称为独占锁。

* 意向锁（Intention Lock）：意向锁是一种表级锁，用于指示一个事务将要在表中的某些数据行上加什么类型的锁。意向锁分为意向共享锁（IS）和意向排他锁（IX），意向共享锁表示一个事务打算在表中的某些数据行上加共享锁，意向排他锁表示一个事务打算在表中的某些数据行上加排他锁。需要特别注意的是：**意向锁是由数据引擎自己维护的，用户无法手动操作意向锁。意向锁之间是互相兼容的！意向锁不会与行级的共享/排他锁互斥！**

    意向锁的作用是为了防止出现死锁和减少开销。当一个事务A要在某表中的某一行数据上加排他锁时（行锁、独占锁），同时事务A会先在表级别上加意向排他锁。如果此时事务B准备在该表上加共享锁（表锁），那么此时事务B要加锁成功，就需要满足此时无事务持有该表的排他锁（表锁）和该表的每一行都无事务持有排他锁（行锁），在没有意向锁的情况下，事务B需要扫描整个表中的每一行才能判断是否满足条件（每一行都需要检测是否有排它锁），而有了意向锁之后，事务B只需要判断是否有事务持有意向排他锁即可，如果没有，则可以加共享锁，如果有，则需要阻塞。

* 更新锁（Update Lock）：更新锁是一种排他锁，它阻止其他事务同时获得相同数据的更新锁或共享锁。更新锁与排他锁是相似的，都是用于防止并发更新问题的悲观锁。主要的区别在于，更新锁的粒度可以更细致，可以应用于某一行而不是整个表。

悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，会出现大量的锁等待，甚至会出现死锁现象。

#### 乐观锁

乐观锁是一种并发控制策略，它基于对数据的乐观估计，认为在事务执行期间其他事务不会对同一数据进行修改，乐观锁不会在事务开始时对数据进行加锁，而是在事务提交时检查是否发生了冲突。乐观锁通常基于数据版本（Version）记录控制实现，何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

##### MVCC（Multi-Version Concurrency Control 多版本并发控制）

多版本并发控制（MVCC）是数据版本中一种常见的实现方式，它通过为每个读取的数据行创建数据在某一时刻的快照，使得读操作不会阻塞写操作，也不会被写操作阻塞，从而提高数据库的并发性能。

下面以MySQL详细说明MVCC的实现原理：

理解MVCC需要知道三个前提知识： **3个记录隐藏字段**、**undo 日志**、**Read View**。

###### 3个记录隐藏字段

虽然在创建表时，明确的指明了对应的列，但是MySQL会默认添加3个隐藏列字段：

* **DB_TRX_ID**：创建或最后修改这个行记录的事务ID。

* **DB_ROLL_PTR**：回滚指针，指向这条记录的上一个版本（上一版本数据一般在undo log中）。

* **DB_ROW_ID**：隐含的自增ID（隐藏主键），如果数据表没有主键， InnoDB会自动以DB_ROW_ID产生一个聚簇索引。

###### undo 日志

undo log可以简单的理解为MySQL中的一段内存缓冲区，用来保存日志数据。MySQL以服务进程的方式运行在内存中，其提供的索引、数据缓冲区、事务、隔离性等，都是在内存中完成的，这些缓冲区用于存储数据和日志，支持各种数据库操作并在合适的时候将相关数据刷新到磁盘。

在每次进行数据操作之后，数据库都会把操作之前的旧值存放到undo log中记录下来，随着更新次数的增多，每次记录都会由隐藏字段中的`DB_ROLL_PTR`指针连接起来形成链表，所形成的链表我们就称之为版本链，链表的头节点就是当前数据最新的节点。所谓的回滚，无非就是用历史数据，覆盖当前数据。**特别注意：只有更新操作才能产生undo log版本。**

假设我们建立如下表结构并写入数据：

```sql
mysql> create table student(
    -> name varchar(11) not null,
    -> age int not null
    -> );
Query OK, 0 rows affected (0.20 sec)

mysql> insert into student (name, age) values ('张三', 28);
Query OK, 1 row affected (0.04 sec)
```

表格我们指定了name和age字段，但实际的表如下图：

![student table column](/images/hide-3-mysql.png)

目前并不知道创建该记录的事务ID，就默认设置成null，隐式主键设置为1，第一条记录也没有其他版本，回滚指针为null。

假设事务ID为10（即DB_TRX_ID=10）对student表中记录进行修改(update)：将name(张三)改成name(李四)。因为要修改，所以要先给该记录加行锁。

修改前，现将改行记录拷贝到undo log中，所以，undo log中就有了一行副本数据(原理就是写时拷贝)。

所以现在MySQL中有两行同样的记录。现在修改原始记录中的name，改成 ‘李四’。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前事务的ID(即将DB_TRX_ID设置为10)，而原始记录的回滚指针`DB_ROLL_PTR`列，里面写入undo log中副本数据的地址，从而指向副本记录，既表示上一个版本就是此副本。

事务提交，释放锁。 此时，最新的记录是’李四‘那条记录。

其过程如下图所示：

![undo log update 1](/images/undo-update-1.png)

假设又有一个事务（假设事务的ID为11），对student表中记录进行修改(update)：将age(28)改成age(38)。

事务11,因为也要修改，所以要先给该记录加行锁。

修改前，现将改行记录拷贝到undo log中，所以undo log中就又有了一行副本数据。此时，新的副本，我们采用头插方式，插入undo log。现在修改原始记录中的age为38。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前事务的ID(即将DB_TRX_ID设置为11)。而原始记录的回滚指针`DB_ROLL_PTR`列，里面写入undo log中副本数据的地址，从而指向副本记录，既表示上一个版本就是此副本。

其过程如下图所示：

![undo log update 2](/images/undo-update-2.png)

从上面的更新中，我们可以得到一个基于链表记录的历史版本链，上面的一个一个版本，我们可以称之为一个一个的快照，而MVCC就是读取undo log中的历史版本（所以也称为快照读），undo log不受加锁限制，也就是可以并行执行，所以提高了效率。

###### Read View

MVCC的主要目标是在并发事务中提供一种机制，使得每个事务都能看到一个一致的数据库快照，而不需要对数据库进行全局锁定。这是通过为每个事务创建一个Read View来实现的，这个Read View代表了事务开始时的数据库状态。

Read View就是事务进行快照读（即不加共享锁和排它锁的普通的SELECT查询，后续会详细解释当前读和快照读）操作的时候生产的读视图，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

Read View 在MySQL源码中就是一个类，本质是用来进行可见性判断的。 即当某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件，用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。

Read View的主要成员如下：

```sql
m_ids; //一张列表，用来维护Read View生成时刻，系统正活跃的事务ID
up_limit_id; //记录m_ids列表中事务ID最小的ID
low_limit_id; //ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1
creator_trx_id //创建该ReadView的事务ID
```

实际读取数据版本链的时候，是能读取到每一个版本对应的事务ID的，即当前记录的DB_TRX_ID。通过快照读的ReadView和版本链中的某一个记录的DB_TRX_ID，就能判定对应的数据版本对当前事务是否可见。

对于Read View中成员的具体值，以及如何判定版本是否可见，使用上述`student`表来进行简单解析，假设我们有如下事务进行操作（假设事务4进行修改操作）：

![student parallel transaction](/images/student-parallel-transaction.png)

当事务2对某行数据执行了快照读，其对应的Read View读视图如下：

```sql
//事务2的 Read View
m_ids; // 1,3
up_limit_id; // 1
low_limit_id; // 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID
creator_trx_id // 2
```

那么事务2在进行快照读时，能否看到事务4提交的版本记录呢？对当前事务来说，按照以下规则从最新的版本开始遍历，获取对应的版本记录：

* 当DB_TRX_ID(隐藏列) == creator_trx_id(创建该ReadView的事务ID)，表示当前事务在访问自己修改的记录，那么此版本对当前事务可见。

* 当DB_TRX_ID(隐藏列) < up_limit_id(活跃事务的最小事务ID)时，up_limit_id是活跃的事务的最小ID，那么说明DB_TRX_ID对应的版本已经提交，那么此版本对当前事务可见。

* 当DB_TRX_ID(隐藏列) > low_limit_id(系统尚未分配的下一个事务ID)时，low_limit是Read View生成时系统尚未分配的下一个事务ID，表明该版本在生成Read View时，还未开启，那么此版本对当前事务不可见。

* 当up_limit_id(活跃事务的最小事务ID) <= DB_TRX_ID <=low_limit_id(系统尚未分配的下一个事务ID)时，如果DB_TRX_ID是在m_ids(Read View生成时刻，系统正活跃的事务ID)中，则不可以访问这个版本，因为在此区间内则说明此当前事务正在进行中还没提交，不能访问其他事务未提交的数据，否则可能会产生脏读；如果不在m_ids(Read View生成时刻，系统正活跃的事务ID)中，说明当前事务已经提交，则可以访问。

###### 从Read View看读已提交和可重读

在介绍事务的隔离级别时，曾经提到，当事务的隔离级别为读已提交时，会出现不可重复读的问题，从Read View版本来看其原因在于，**在读已提交的隔离级别下，事务每进行一次快照读，都会生成不同的Read View；而在可重读的隔离级别下，事务不论进行多少次快照读，都使用的同一个Read View**。

假设现在有事务A和事务B两个事务并发操作一行数据。事务A执行了两次查询操作，事务B执行了一次更新操作。

事务A执行第一次查询操作，先生成Read View，我们姑且称之为Read View_1，还未开始查询操作，事务B率先执行了更新操作，将数据进行了修改并提交，事务B结束，此时事务A第一次查询开始，但由于事务A已经生成了Read View_1，所以它不会读取到事务B修改过后的数据，读取到的是Read View_1中事务B修改之前的数据，解决了脏读的问题；然后，事务A进行第二次查询操作。注意！！！这里它又生成了一个Read View，我们称之为ReadView_2，此时的ReadView_2中的数据是已经被事务B修改后的数据了，事务A再次进行查询，发现查询到的数据和刚操第一次查询到的不一样了，就产生了不可重复读的问题。

而对于可重读隔离级别下，事务A进行第二次查询操作时，不会生成新的Read View，仍然读取的是Read View_1，并且此后事务A不论进行多少次查询，事实上读取的都是同一个Read View，所以解决了不可重读的问题。

### 快照读与当前读

#### 快照读

在介绍MVCC时，曾提到过MVCC就是读取undo log中的历史版本，这些对应的历史版本我们称之为快照，对于这种读取历史数据的方式，称之为快照读(snapshot read)。虽然MVCC让读操作和写操作可以并发进行，不再相互阻塞，也在某些隔离级别下实现了数据的可重读，但读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。

在MVCC中，快照读就是普通的SELECT查询，如下：

```sql
SELECT * FROM table;
```

#### 当前读

与快照读相对的，读取数据库当前版本数据的方式，叫当前读 (current read)。当前读是一种锁定读，它读取的是数据的最新版本，即使这个版本是在当前事务开始后创建的。因此，当前读需要等待写操作，也可能被写操作阻塞。需要特别注意的是，**插入/更新/删除操作也属于当前读**，处理的都是当前的数据，需要加锁。

当前读分为以下几种方式：

```sql
-- 排它锁
SELECT * FROM table FOR UPDATE;
-- 共享锁
SELECT * FROM table LOCK IN SHARE MODE;
-- 新增
INSERT INTO table VALUES(...);
-- 更新
UPDATE table SET ...;
-- 删除
DELETE FROM table WHERE ...;
```
