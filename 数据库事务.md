---
title: 数据库事务
date: 2023-11-11 18:16:05
tags: [数据库, 事务]
---

## 什么是数据库事务以及为什么需要事务

事务（Transaction）是指数据库管理系统执行的一个或一组操作单元，这些操作要么全部执行成功，要么全部不执行，即事务具有原子性（Atomicity）。事务是确保数据一致性和完整性的一种机制。

数据库事务是指数据库系统中执行的一系列相关的操作，这些操作被视为一个逻辑单元，要么全部执行成功，要么全部执行失败，没有中间状态。数据库事务通常涉及对数据库中的数据进行读写操作，例如插入、更新、删除等。

数据库事务的存在是为了确保数据的一致性、完整性和可靠性。

### 数据库事务的特性（ACID）

数据库事务具有以下四个特性，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），通常称为事务的 ACID 特性。

* 原子性（Atomicity）：事务是一个不可分割的工作单元，要么全部执行成功，要么全部不执行。如果事务的任何部分操作失败，整个事务将被回滚，恢复到最初的状态。请注意，原子性并不意味着一个事务的操作无法被另一个事务打断，在并发环境下，多个事务可能会交错执行，调度器会根据具体的并发控制协议来决定事务的执行顺序。然而即使被打断，仍然会保证最终全部执行成功或者全部被回滚。

* 一致性（Consistency）：事务在执行前后，数据库的状态应保持一致。事务必须使数据库从一个一致性状态变换到另一个一致性状态。

* 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离性确保在并发执行的多个事务之间，每个事务看到的数据是独立的，互不干扰，防止并发执行事务时出现一些意外的、不一致的结果。数据库系统通过实现不同的隔离级别来控制事务之间的可见性，从而提供不同程度的隔离性。

* 持久性（Durability）：事务一旦提交，对数据库的修改就是永久性的，即使系统故障也不应该对其有任何影响，持久性确保数据的可靠性和长期保存。

<!-- more -->

### 事务的隔离级别

隔离性定义了在并发事务之间对数据的可见性（即一个事务的更新数据对另一个事务的可见性），数据库锁就是为了构建这些隔离级别存在的。数据库系统通过实现不同的隔离级别来控制事务之间的可见性，从而提供不同程度的隔离性。隔离级别越高，事务之间的隔离程度越高，但是并发性越低，系统的开销越大。

数据库系统通常实现了以下四种隔离级别：

* 读未提交（Read Uncommitted）：事务中的修改，即使没有提交，对其他事务也是可见的。最低的隔离级别。在这个级别，一个事务可以看到其他事务未提交的修改。

* 读提交（Read Committed）：事务提交后，它的修改才会对其他事务可见。这是大多数数据库系统的默认隔离级别。在这个级别，一个事务只能看到其他事务已提交的修改。

* 可重复读（Repeatable Read）：一个事务在多次执行同一查询时，同一查询将返回相同的结果，即使其他事务对数据进行了修改并提交。

* 串行化（Serializable）：最高级别的隔离，确保事务之间的完全隔离，事务串行化执行。读数据会加上共享锁，读写会相互阻塞，不允许并发执行，可能会产生大量的超时现象和锁竞争。

需要特别注意的是，不同的数据库系统对隔离级别的实现可能不同，对于同一隔离级别，其具体的实现细节也略微有不同，也会展现不同的具体特征。

### 并发事务带来的问题

事务的隔离级别定义了并发事务之间对数据的可见性同时，也带来了一些问题：

* 脏读（Dirty Read）：一个事务读取了另一个事务未提交的数据，如果另一个事务回滚，则读取到的数据是无效的。假设有两个并发事务T1和T2，T1读取了T2未提交的数据，如果T2回滚，则T1读取到的数据是无效的，这种现象称为脏读。

* 不可重复读（Non-Repeatable Read）：一个事务内多次读取同一数据，但在两次读取之间，另一个事务修改了数据并提交，导致两次读取的结果不一致。假设有两个并发事务T1和T2。T1读取了一条数据，然后T2修改了这条数据并提交。此时，如果T1再次读取这条数据，就会发现数据已经被改变。这就是不可重复读。

* 幻读（Phantom Read）：一个事务内多次执行同一个查询，但在两次查询之间，另一个事务插入了符合该查询条件的新数据，导致两次查询的结果不一致。假设有两个并发事务T1和T2。T1读取了一批数据，然后T2插入了一些数据。此时，如果T1再次读取相同的数据，就会发现有些数据是之前没有的，这就是幻读。**注意幻读和不可重复读的区别：不可重复读针对的是修改，幻读针对的是新增或删除。**

* 丢失更新（Lost Update）：两个事务同时读取同一数据，然后同时修改该数据并提交，导致其中一个事务的修改被覆盖。假设有两个并发事务T1和T2。T1、T2读取同一条数据，随后T1修改了这条数据并提交，然后T2也修改了这条数据并提交。这时，T1的修改被覆盖了，这就是丢失更新。

### 不同隔离级别下并发事务可能出现的问题

| 隔离级别 | 脏读（Dirty Read） | 不可重复读（Non-Repeatable Read） | 幻读（Phantom Read） | 丢失更新（Lost Update） |
| :---: | :---: | :---: | :---: | :---: |
| 读未提交（Read Uncommitted） | Possible | Possible | Possible | Possible |
| 读提交（Read Committed） | Not Possible | Possible | Possible | Possible |
| 可重复读（Repeatable Read） | Not Possible | Not Possible | Possible | Possible |
| 串行化（Serializable） | Not Possible | Not Possible | Not Possible | Not Possible |

**需要特别注意的是，以上表格中的可能出现的问题并不绝对，部分数据库的同一隔离级别实现仍有不同，因此并不会出现对应的问题。**例如在ANSI SQL STANDARD的标准定义中（如下图所示），在可重读隔离级别下是允许出现幻读，但是PGSQL的可重读隔离级别下，却不会出现幻读：

![ANSI SQL STANDARD](/images/ANSI_SQL_STANDARD.jpg)

### 悲观锁与乐观锁

当多个并发事务在某一隔离级别下同时操纵同一数据时，如果不加以控制，就可能会出现上述的问题。为了解决这些问题，数据库系统提供了两种不同的并发控制机制，分别是悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）。

#### 悲观锁

悲观锁是一种并发控制策略，它基于对数据的悲观估计，认为在事务执行期间其他事务可能会对同一数据进行修改。为了防止这种情况，悲观锁在事务访问数据时会对其进行加锁，以限制其他事务的并发访问，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（只有数据库层提供的锁机制才能真正保证数据访问的排他性，应用层面的加锁机制是无法保证外部系统无法修改数据）。

悲观锁一般分为如下几类：

* 共享锁（Shared Lock）：又称为读锁，允许事务读取一行数据，阻止其他事务获得相同数据集的排他锁，但是允许其他事务获得相同数据集的共享锁，即可以查看但无法修改和删除的一种数据锁，适用于读多写少的场景。

* 排他锁（Exclusive Lock）：又称为写锁，允许事务读取和修改一行数据，阻止其他事务获得相同数据集的共享锁和排他锁（即其他事务无法读取和修改），因此排他锁又称为独占锁。

* 意向锁（Intention Lock）：意向锁是一种表级锁，用于指示一个事务将要在表中的某些数据行上加什么类型的锁。意向锁分为意向共享锁（IS）和意向排他锁（IX），意向共享锁表示一个事务打算在表中的某些数据行上加共享锁，意向排他锁表示一个事务打算在表中的某些数据行上加排他锁。需要特别注意的是：**意向锁是由数据引擎自己维护的，用户无法手动操作意向锁。意向锁之间是互相兼容的！意向锁不会与行级的共享/排他锁互斥！**

    意向锁的作用是为了防止出现死锁和减少开销。当一个事务A要在某表中的某一行数据上加排他锁时（行锁、独占锁），同时事务A会先在表级别上加意向排他锁。如果此时事务B准备在该表上加共享锁（表锁），那么此时事务B要加锁成功，就需要满足此时无事务持有该表的排他锁（表锁）和该表的每一行都无事务持有排他锁（行锁），在没有意向锁的情况下，事务B需要扫描整个表中的每一行才能判断是否满足条件（每一行都需要检测是否有排它锁），而有了意向锁之后，事务B只需要判断是否有事务持有意向排他锁即可，如果没有，则可以加共享锁，如果有，则需要阻塞。

* 更新锁（Update Lock）：更新锁是一种排他锁，它阻止其他事务同时获得相同数据的更新锁或共享锁。更新锁与排他锁是相似的，都是用于防止并发更新问题的悲观锁。主要的区别在于，更新锁的粒度可以更细致，可以应用于某一行而不是整个表。

悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，会出现大量的锁等待，甚至会出现死锁现象。

#### 乐观锁

乐观锁是一种并发控制策略，它基于对数据的乐观估计，认为在事务执行期间其他事务不会对同一数据进行修改，乐观锁不会在事务开始时对数据进行加锁，而是在事务提交时检查是否发生了冲突。乐观锁通常基于数据版本（Version）记录控制实现，何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

##### MVCC（Multi-Version Concurrency Control 多版本并发控制）

多版本并发控制（MVCC）是数据版本中一种常见的实现方式，它通过为每个读取的数据行创建数据在某一时刻的快照，使得读操作不会阻塞写操作，也不会被写操作阻塞，从而提高数据库的并发性能。

下面以MySQL详细说明MVCC的实现原理：

理解MVCC需要知道三个前提知识： **3个记录隐藏字段**、**undo 日志**、**Read View**。

###### 3个记录隐藏字段

虽然在创建表时，明确的指明了对应的列，但是MySQL会默认添加3个隐藏列字段：

* **DB_TRX_ID**：创建或最后修改这个行记录的事务ID。

* **DB_ROLL_PTR**：回滚指针，指向这条记录的上一个版本（上一版本数据一般在undo log中）。

* **DB_ROW_ID**：隐含的自增ID（隐藏主键），如果数据表没有主键， InnoDB会自动以DB_ROW_ID产生一个聚簇索引。

###### undo 日志

undo log可以简单的理解为MySQL中的一段内存缓冲区，用来保存日志数据。MySQL以服务进程的方式运行在内存中，其提供的索引、数据缓冲区、事务、隔离性等，都是在内存中完成的，这些缓冲区用于存储数据和日志，支持各种数据库操作并在合适的时候将相关数据刷新到磁盘。

在每次进行数据操作之后，数据库都会把操作之前的旧值存放到undo log中记录下来，随着更新次数的增多，每次记录都会由隐藏字段中的`DB_ROLL_PTR`指针连接起来形成链表，所形成的链表我们就称之为版本链，链表的头节点就是当前数据最新的节点。所谓的回滚，无非就是用历史数据，覆盖当前数据。**特别注意：只有更新操作才能产生undo log版本。**

假设我们建立如下表结构并写入数据：

```sql
mysql> create table student(
    -> name varchar(11) not null,
    -> age int not null
    -> );
Query OK, 0 rows affected (0.20 sec)

mysql> insert into student (name, age) values ('张三', 28);
Query OK, 1 row affected (0.04 sec)
```

表格我们指定了name和age字段，但实际的表如下图：

![student table column](/images/hide-3-mysql.png)

目前并不知道创建该记录的事务ID，就默认设置成null，隐式主键设置为1，第一条记录也没有其他版本，回滚指针为null。

假设事务ID为10（即DB_TRX_ID=10）对student表中记录进行修改(update)：将name(张三)改成name(李四)。因为要修改，所以要先给该记录加行锁。

修改前，现将改行记录拷贝到undo log中，所以，undo log中就有了一行副本数据(原理就是写时拷贝)。

所以现在MySQL中有两行同样的记录。现在修改原始记录中的name，改成 ‘李四’。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前事务的ID(即将DB_TRX_ID设置为10)，而原始记录的回滚指针`DB_ROLL_PTR`列，里面写入undo log中副本数据的地址，从而指向副本记录，既表示上一个版本就是此副本。

事务提交，释放锁。 此时，最新的记录是’李四‘那条记录。

其过程如下图所示：

![undo log update 1](/images/undo-update-1.png)

假设又有一个事务（假设事务的ID为11），对student表中记录进行修改(update)：将age(28)改成age(38)。

事务11,因为也要修改，所以要先给该记录加行锁。

修改前，现将改行记录拷贝到undo log中，所以undo log中就又有了一行副本数据。此时，新的副本，我们采用头插方式，插入undo log。现在修改原始记录中的age为38。并且修改原始记录的隐藏字段`DB_TRX_ID`为当前事务的ID(即将DB_TRX_ID设置为11)。而原始记录的回滚指针`DB_ROLL_PTR`列，里面写入undo log中副本数据的地址，从而指向副本记录，既表示上一个版本就是此副本。

其过程如下图所示：

![undo log update 2](/images/undo-update-2.png)

从上面的更新中，我们可以得到一个基于链表记录的历史版本链，上面的一个一个版本，我们可以称之为一个一个的快照，而MVCC就是读取undo log中的历史版本（所以也称为快照读），undo log不受加锁限制，也就是可以并行执行，所以提高了效率。

###### Read View

MVCC的主要目标是在并发事务中提供一种机制，使得每个事务都能看到一个一致的数据库快照，而不需要对数据库进行全局锁定。这是通过为每个事务创建一个Read View来实现的，这个Read View代表了事务开始时的数据库状态。

Read View就是事务进行快照读（即不加共享锁和排它锁的普通的SELECT查询，后续会详细解释当前读和快照读）操作的时候生产的读视图，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

Read View 在MySQL源码中就是一个类，本质是用来进行可见性判断的。 即当某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件，用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。

Read View的主要成员如下：

```sql
m_ids; //一张列表，用来维护Read View生成时刻，系统正活跃的事务ID
up_limit_id; //记录m_ids列表中事务ID最小的ID
low_limit_id; //ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1
creator_trx_id //创建该ReadView的事务ID
```

实际读取数据版本链的时候，是能读取到每一个版本对应的事务ID的，即当前记录的DB_TRX_ID。通过快照读的ReadView和版本链中的某一个记录的DB_TRX_ID，就能判定对应的数据版本对当前事务是否可见。

对于Read View中成员的具体值，以及如何判定版本是否可见，使用上述`student`表来进行简单解析，假设我们有如下事务进行操作（假设事务4进行修改操作）：

![student parallel transaction](/images/student-parallel-transaction.png)

当事务2对某行数据执行了快照读，其对应的Read View读视图如下：

```sql
//事务2的 Read View
m_ids; // 1,3
up_limit_id; // 1
low_limit_id; // 4 + 1 = 5，原因：ReadView生成时刻，系统尚未分配的下一个事务ID
creator_trx_id // 2
```

那么事务2在进行快照读时，能否看到事务4提交的版本记录呢？对当前事务来说，按照以下规则从最新的版本开始遍历，获取对应的版本记录：

* 当DB_TRX_ID(隐藏列) == creator_trx_id(创建该ReadView的事务ID)，表示当前事务在访问自己修改的记录，那么此版本对当前事务可见。

* 当DB_TRX_ID(隐藏列) < up_limit_id(活跃事务的最小事务ID)时，up_limit_id是活跃的事务的最小ID，那么说明DB_TRX_ID对应的版本已经提交，那么此版本对当前事务可见。

* 当DB_TRX_ID(隐藏列) > low_limit_id(系统尚未分配的下一个事务ID)时，low_limit是Read View生成时系统尚未分配的下一个事务ID，表明该版本在生成Read View时，还未开启，那么此版本对当前事务不可见。

* 当up_limit_id(活跃事务的最小事务ID) <= DB_TRX_ID <=low_limit_id(系统尚未分配的下一个事务ID)时，如果DB_TRX_ID是在m_ids(Read View生成时刻，系统正活跃的事务ID)中，则不可以访问这个版本，因为在此区间内则说明此当前事务正在进行中还没提交，不能访问其他事务未提交的数据，否则可能会产生脏读；如果不在m_ids(Read View生成时刻，系统正活跃的事务ID)中，说明当前事务已经提交，则可以访问。

###### 从Read View看读已提交和可重读

在介绍事务的隔离级别时，曾经提到，当事务的隔离级别为读已提交时，会出现不可重复读的问题，从Read View版本来看其原因在于，**在读已提交的隔离级别下，事务每进行一次快照读，都会生成不同的Read View；而在可重读的隔离级别下，事务不论进行多少次快照读，都使用的同一个Read View**。

假设现在有事务A和事务B两个事务并发操作一行数据。事务A执行了两次查询操作，事务B执行了一次更新操作。

事务A执行第一次查询操作，先生成Read View，我们姑且称之为Read View_1，还未开始查询操作，事务B率先执行了更新操作，将数据进行了修改并提交，事务B结束，此时事务A第一次查询开始，但由于事务A已经生成了Read View_1，所以它不会读取到事务B修改过后的数据，读取到的是Read View_1中事务B修改之前的数据，解决了脏读的问题；然后，事务A进行第二次查询操作。注意！！！这里它又生成了一个Read View，我们称之为ReadView_2，此时的ReadView_2中的数据是已经被事务B修改后的数据了，事务A再次进行查询，发现查询到的数据和刚操第一次查询到的不一样了，就产生了不可重复读的问题。

而对于可重读隔离级别下，事务A进行第二次查询操作时，不会生成新的Read View，仍然读取的是Read View_1，并且此后事务A不论进行多少次查询，事实上读取的都是同一个Read View，所以解决了不可重读的问题。

### 快照读与当前读

#### 快照读

在介绍MVCC时，曾提到过MVCC就是读取undo log中的历史版本，这些对应的历史版本我们称之为快照，对于这种读取历史数据的方式，称之为快照读(snapshot read)。虽然MVCC让读操作和写操作可以并发进行，不再相互阻塞，也在某些隔离级别下实现了数据的可重读，但读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！这在一些对于数据的时效特别敏感的业务中，就很可能出问题。

在MVCC中，快照读就是普通的SELECT查询，如下：

```sql
SELECT * FROM table;
```

#### 当前读

与快照读相对的，读取数据库当前版本数据的方式，叫当前读 (current read)。当前读是一种锁定读，它读取的是数据的最新版本，即使这个版本是在当前事务开始后创建的。因此，当前读需要等待写操作，也可能被写操作阻塞。需要特别注意的是，**插入/更新/删除操作也属于当前读**，处理的都是当前的数据，需要加锁。

当前读分为以下几种方式：

```sql
-- 排它锁
SELECT * FROM table FOR UPDATE;
-- 共享锁
SELECT * FROM table LOCK IN SHARE MODE;
-- 新增
INSERT INTO table VALUES(...);
-- 更新
UPDATE table SET ...;
-- 删除
DELETE FROM table WHERE ...;
```

### 数据库锁

MVCC为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。而所有的当前读，都需要使用数据库锁来进行控制，以保证数据的正确性。常见的数据库锁如下：

* 表锁：表锁是数据库中较粗粒度的锁，它锁定的是整个表，包括表中的所有数据行。其加锁粒度是较大的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度较大，但触发锁冲突的概率较高，并发度较低。在并发事务中，当某一事务持有某张表的表锁时，其它事务的当前读必须等待持有表锁的事务释放表锁后才能访问此表的数据。

* 行锁：行锁是数据库中最细粒度的锁，它锁定的是单个的数据行（需要注意，并不是只锁定一行数据，如果对某范围数据中的每一行都上锁，依然称之为行锁），行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。在并发事务中，当某一事务持有某行数据的行锁时，其它事务的当前读必须等待持有行锁的事务释放锁后才能访问这行数据。

    需要注意行锁、表锁与之前介绍的共享锁、排它锁的区别，行锁和表锁是从锁的粒度来进行的锁的定义，而排他锁、共享锁是一种锁的类型或者模式，是对被锁定资源的访问权限的描述；并且在某些情况下，行锁可能会退化成表锁，以InnoDB为例：

  * 无可用索引：如果一条SQL语句在执行过程中没有使用索引，那么InnoDB无法使用行锁，只能使用表锁。因此在执行更新或对记录加排它锁时，需要特别注意能否使用索引，否则InnoDB将会给所有数据会加上行锁（实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，MySQL Server过滤数据的的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象）。

  * 外键约束：如果表之间存在外键约束的情况下，在更新或删除一个表中的行，可能需要锁定其他表中的相关行，这可能导致行锁退化为表锁（因此推荐在业务层面而不是在数据库层面实现外键约束）。

* GAP锁（间隙锁）：间隙锁（Gap Lock）是一种特殊类型的锁，它锁定的不是表中的实际行，而是索引记录之间的间隙。间隙锁的主要目的是防止幻读（Phantom Read），即防止其他事务在该范围内插入新的记录，从而确保事务读取数据的一致性。间隙锁通常和行锁一起使用，形成了一种叫做“临键锁”（Next-Key Lock）的锁。行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。需要特别注意的是，**间隙锁只在可重复读（REPEATABLE READ）和串行化（SERIALIZABLE）这两个隔离级别下有效。**

  为了更好的理解间隙锁的定义，参考如下示例：

  ```sql
  CREATE TABLE `class_teacher` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `class_name` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
    `teacher_id` int(11) NOT NULL,
    PRIMARY KEY (`id`),
    KEY `idx_teacher_id` (`teacher_id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
  ```

  执行全表查询语句后，输出如下数据

  ```text
    mysql> select * from class_teacher;
    +----+--------------+------------+
    | id | class_name   | teacher_id |
    +----+--------------+------------+
    |  1 | 初三一班     |          1 |
    |  2 | 初三二班     |         30 |
    |  3 | 初二一班     |          2 |
    |  4 | 初二二班     |          2 |
    +----+--------------+------------+
  ```

现在有两个事务，事务A和事务B，当事务的隔离级别为RC时（无GAP锁）：

![Read Commit-Phantom Read](/images/RC-Phantom_Read.jpg)

可以看到，当在RC隔离级别下，事务A最终读取到了事务B新写入的数据，也就是出现了幻读。

当事务的隔离级别为RR时（有GAP锁）：

![Repeatable Read-No Phantom Read](/images/RR-No_Phantom_Read.png)

可以看到，事务A在update后加锁，事务B无法插入新数据，这样事务A在update前后读的数据保持一致，避免了幻读。这个锁，就是GAP锁。

GAP锁是在事务中对范围进行加锁，GAP锁会锁定两个值之间的间隙，即范围查询的结果集中不存在的记录范围。以上面的示例来详细说明间隙锁锁住的范围：

在class_teacher这张表中，teacher_id是个索引，那么它就会维护一套B+树的数据关系，为了简化，我们用链表结构来表达（实际上是个树形结构，但原理相同）

![gap lock](/images/gap_lock.jpg)

如图所示，InnoDB使用的是聚集索引，teacher_id身为二级索引，就要维护一个索引字段和主键id的树状结构（这里用链表形式表现），并保持顺序排列。

Innodb将这段数据分成几个区间：

* (negative infinity, 5]

* (5, 30]

* (30, positive infinity)

当事务A执行更新语句时（update class_teacher set class_name=‘初三四班’ where teacher_id=30），不仅用行锁，锁住了相应的数据行；同时也在两边的区间，（5,30]和（30，positive infinity），都加入了GAP锁。这样事务B就无法在这个两个区间insert进新数据。

受限于这种实现方式，Innodb很多时候会锁住不需要锁的区间。如下所示：

![gap lock 2](/images/gap-range_lock.jpg)

update的teacher_id=20是在(5，30]区间，即使没有修改任何数据，Innodb也会在这个区间加GAP锁，而其它区间不会影响，事务C正常插入。

如果使用的是没有索引的字段，比如update class_teacher set teacher_id=7 where class_name=‘初三八班（即使没有匹配到任何数据）’,那么会给全表加入GAP锁。同时，它不能像行锁一样经过MySQL Server过滤自动解除不满足条件的锁，因为没有索引，则这些字段也就没有排序，也就没有区间。除非该事务提交，否则其它事务无法插入任何数据。**因此在执行更新操作或者施加排它锁时，一定要特别注意能否通过索引定位到对应的数据，尽量避免给全表加入GAP锁。**

实际InnoDB的GAP锁的范围非常复杂（如果存在索引，通常GAP锁是根据检索条件向下寻找最靠近检索条件的索引记录值A作为左区间，向上寻找最靠近检索条件的索引记录值B作为右区间，即锁定的间隙为（A，B] 左开右闭；如果不存在索引，那么将全表加入GAP锁），不仅仅与索引类型密切相关，还与主键等密切相关，以下对常见的做一个简单总结：

#### 唯一索引

* 如果通过唯一索引锁定某一行记录，则不会产生GAP锁，只会为对应行增加行锁。

* 如果通过唯一索引锁定某一行记录，但是该行记录不存在，则会产生GAP锁。

* 如果通过唯一索引锁定多行记录（即范围检索），会产生GAP锁。

#### 普通索引（二级索引）

* 如果通过普通索引锁定某一行记录或锁定多行记录（即范围检索），都会产生GAP锁。

* 如果通过普通索引锁定不存在的记录，会产生GAP锁。

#### 无索引

* 无索引全表加入GAP锁。

为了更好的理解GAP锁的加锁范围，同时直观的展示主键对GAP锁的影响，下面通过一个实例来进行说明，假设存在如下表和数据：

```sql
CREATE TABLE `test` (
  `id` int(11) NOT NULL default '0',
  `v1` int(11) default NULL,
  `v2` int(11) default NULL,
  `v3` int(10) unsigned NOT NULL default '0',
  PRIMARY KEY  (`id`),
  UNIQUE KEY `v3` (`v3`),
  KEY `idx_v1` (`v1`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

执行全表查询语句后，输出如下数据:

```text
mysql> select * from test;

+----+------+------+----+
| id | v1   | v2   | v3 |
+----+------+------+----+
|  0 |    4 |   15 |  0 |
|  1 |    1 |    0 |  1 |
|  2 |    3 |    1 |  2 |
|  3 |    4 |    2 |  3 |
|  5 |    5 |    9 |  5 |
|  7 |    7 |    4 |  7 |
|  8 |    7 |    3 |  8 |
| 10 |    9 |    5 | 10 |
| 30 |    8 |   15 | 30 |
+----+------+------+----+
```

随后开启两个事务分别执行如下脚本：

| session1 | session2 |
| :--- | :--- |
| begin |   |
|   | begin |
| update test set v2=1000 where v1=7 |   |
|   | update test set v1=6 where v1=9; //阻塞 |
|   | update test set v1=8 where v1=9; //阻塞 |
|   | update test set v1=5 where v1=9; //阻塞 |
|   | update test set v1=9 where v1=9; //success |

根据V1列查找要更新的记录，由于V1列是非唯一索引，在默认的Repeatable Read事务隔离级别下需要加X Gap Lock。

根据V1的数值，存在的Gap有（-∞,1],(1,3],(3,4],(4,4],(4,5],(5,7],(7,7],(7,8],(8,9],(9,+∞)。

MySQL将数据按照聚集索引存储，所以数据存放的物理顺序为ID从0-30依次存放。

而在v1索引中，数据的索引顺序为：行(v1=5,id=5),行(v1=7,id=7),行(v1=7,id=8),行(v1=8,id=30),行(v1=9,id=10)。

在session1中要更新的是v1=7的两行，这两行数据的Gap为：(v1=5,id=5),(v1=8,id=30)。这个Gap锁定后，新插入或者修改的数据，v1值的索引顺序不能在这个Gap之间。

下面来分析session2的四个语句:

* 假设1语句设置v1=6执行成功后，则v1索引数据会变为：(v1=5,id=5),行(v1=6,id=10),行(v1=7,id=7),行(v1=7,id=8),行(v1=8,id=30)。这就在(v1=5,id=5),(v1=8,id=30)这个Gap之间插入了索引数据(v1=6,id=10)，所以会阻塞，以等待session1的X Gap锁释放。验证：将update test set v1=4 where v1=9就不会阻塞。

* 假设2语句设置v1=8执行成功后，则v1索引数据会变为：(v1=5,id=5),行(v1=7,id=7),行(v1=7,id=8),行(v1=8,id=10),行(v1=8,id=30)。因为会产生2个v1=8的行，而新的行id=10在id=30的行前，这也就在(v1=5,id=5),(v1=8,id=30)这个Gap之间插入了索引数据，所以会阻塞（受主键影响）。验证：将v1=9的行id设置为40，该语句就不会阻塞。

* 假设3语句设置v1=5执行成功后，则v1索引数据会变为：行(v1=5,id=5),行(v1=5,id=10),行(v1=7,id=7),行(v1=7,id=8),行(v1=8,id=30)。同样会在V1索引的Gap中插入索引数据，所以会阻塞（受主键影响）。将v1=9的行id设置为-1，该语句就不会阻塞。

* 假设该语句执行成功后，则v1索引数据仍为：行(v1=5,id=5),行(v1=7,id=7),行(v1=7,id=8),行(v1=8,id=30),行(v1=9,id=10)。并没有在Gap(v1=5,id=5),(v1=8,id=30)中插入任何数据，不会阻塞。

综上：设置v1=6是会一直阻塞的，设置v1=5和v1=8在不同的id下会有不同表现，部分可以实现，部分会阻塞。

下面从MySQL的系统表查看上述语句对应的锁信息，从而分析上述**受主键影响**的语句执行结果：

| INDEX_NAME | OBJECT_INSTANCE_BEGIN | LOCK_TYPE | LOCK_MODE | LOCK_STATUS | LOCK_DATA |
| :---: | :---: | :---: | :---: | :---: | :---: |
| NULL | 3104222809880 | TABLE | IX | GRANTED | NULL |
| idx_v1 | 3104221498392 | RECORD | X | GRANTED | 7,7 |
| idx_v1 | 3104221498392 | RECORD | X | GRANTED | 7,8 |
| PRIMARY | 3104221498736 | RECORD | X,REC_NOT_GAP | GRANTED | 7 |
| PRIMARY | 3104221498736 | RECORD | X,REC_NOT_GAP | GRANTED | 8 |
| idx_v1 | 3104221499080 | RECORD | X,GAP | GRANTED | 8,30 |

第一个是意向排他锁，不分析。

第二个第三个锁是next-key锁，锁定((id=5,v1=5),(id=7,v1=7)]和((id=7,v1=7),(id=8,v1=7)]两个区间。

第四个第五个是记录锁，锁定id=7和id=8两个区间。

第六个是间隙锁，锁定((id=8,v1=7),(id=30,v1=8))这个开区间。

纵观所有的锁，并未锁定v1=5和v1=8两个数据记录。只不过更新后v1的数值落在了上述第二、三、四、五、六个锁的范围内，所以会阻塞。
