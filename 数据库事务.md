---
title: 数据库事务
date: 2023-11-11 18:16:05
tags: [数据库, 事务]
---

## 什么是数据库事务以及为什么需要事务

事务（Transaction）是指数据库管理系统执行的一个或一组操作单元，这些操作要么全部执行成功，要么全部不执行，即事务具有原子性（Atomicity）。事务是确保数据一致性和完整性的一种机制。

数据库事务是指数据库系统中执行的一系列相关的操作，这些操作被视为一个逻辑单元，要么全部执行成功，要么全部执行失败，没有中间状态。数据库事务通常涉及对数据库中的数据进行读写操作，例如插入、更新、删除等。

数据库事务的存在是为了确保数据的一致性、完整性和可靠性。

### 数据库事务的特性（ACID）

数据库事务具有以下四个特性，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），通常称为事务的 ACID 特性。

* 原子性（Atomicity）：事务是一个不可分割的工作单元，要么全部执行成功，要么全部不执行。如果事务的任何部分操作失败，整个事务将被回滚，恢复到最初的状态。请注意，原子性并不意味着一个事务的操作无法被另一个事务打断，在并发环境下，多个事务可能会交错执行，调度器会根据具体的并发控制协议来决定事务的执行顺序。然而即使被打断，仍然会保证最终全部执行成功或者全部被回滚。

* 一致性（Consistency）：事务在执行前后，数据库的状态应保持一致。事务必须使数据库从一个一致性状态变换到另一个一致性状态。

* 隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离性确保在并发执行的多个事务之间，每个事务看到的数据是独立的，互不干扰，防止并发执行事务时出现一些意外的、不一致的结果。数据库系统通过实现不同的隔离级别来控制事务之间的可见性，从而提供不同程度的隔离性。

* 持久性（Durability）：事务一旦提交，对数据库的修改就是永久性的，即使系统故障也不应该对其有任何影响，持久性确保数据的可靠性和长期保存。

### 事务的隔离级别

隔离性定义了在并发事务之间对数据的可见性（即一个事务的更新数据对另一个事务的可见性），数据库锁就是为了构建这些隔离级别存在的。数据库系统通过实现不同的隔离级别来控制事务之间的可见性，从而提供不同程度的隔离性。隔离级别越高，事务之间的隔离程度越高，但是并发性越低，系统的开销越大。

数据库系统通常实现了以下四种隔离级别：

* 读未提交（Read Uncommitted）：事务中的修改，即使没有提交，对其他事务也是可见的。最低的隔离级别。在这个级别，一个事务可以看到其他事务未提交的修改。

* 读提交（Read Committed）：事务提交后，它的修改才会对其他事务可见。这是大多数数据库系统的默认隔离级别。在这个级别，一个事务只能看到其他事务已提交的修改。

* 可重复读（Repeatable Read）：一个事务在多次执行同一查询时，同一查询将返回相同的结果，即使其他事务对数据进行了修改并提交。

* 串行化（Serializable）：最高级别的隔离，确保事务之间的完全隔离，事务串行化执行。读数据会加上共享锁，读写会相互阻塞，不允许并发执行，可能会产生大量的超时现象和锁竞争。

需要特别注意的是，不同的数据库系统对隔离级别的实现可能不同，对于同一隔离级别，其具体的实现细节也略微有不同，也会展现不同的具体特征。

### 并发事务带来的问题

事务的隔离级别定义了并发事务之间对数据的可见性同时，也带来了一些问题：

* 脏读（Dirty Read）：一个事务读取了另一个事务未提交的数据，如果另一个事务回滚，则读取到的数据是无效的。假设有两个并发事务T1和T2，T1读取了T2未提交的数据，如果T2回滚，则T1读取到的数据是无效的，这种现象称为脏读。

* 不可重复读（Non-Repeatable Read）：一个事务内多次读取同一数据，但在两次读取之间，另一个事务修改了数据并提交，导致两次读取的结果不一致。假设有两个并发事务T1和T2。T1读取了一条数据，然后T2修改了这条数据并提交。此时，如果T1再次读取这条数据，就会发现数据已经被改变。这就是不可重复读。

* 幻读（Phantom Read）：一个事务内多次执行同一个查询，但在两次查询之间，另一个事务插入了符合该查询条件的新数据，导致两次查询的结果不一致。假设有两个并发事务T1和T2。T1读取了一批数据，然后T2插入了一些数据。此时，如果T1再次读取相同的数据，就会发现有些数据是之前没有的，这就是幻读。**注意幻读和不可重复读的区别：不可重复读针对的是修改，幻读针对的是新增或删除。**

* 丢失更新（Lost Update）：两个事务同时读取同一数据，然后同时修改该数据并提交，导致其中一个事务的修改被覆盖。假设有两个并发事务T1和T2。T1、T2读取同一条数据，随后T1修改了这条数据并提交，然后T2也修改了这条数据并提交。这时，T1的修改被覆盖了，这就是丢失更新。

### 不同隔离级别下并发事务可能出现的问题

| 隔离级别 | 脏读（Dirty Read） | 不可重复读（Non-Repeatable Read） | 幻读（Phantom Read） | 丢失更新（Lost Update） |
| :---: | :---: | :---: | :---: | :---: |
| 读未提交（Read Uncommitted） | Possible | Possible | Possible | Possible |
| 读提交（Read Committed） | Not Possible | Possible | Possible | Possible |
| 可重复读（Repeatable Read） | Not Possible | Not Possible | Possible | Possible |
| 串行化（Serializable） | Not Possible | Not Possible | Not Possible | Not Possible |

**需要特别注意的是，以上表格中的可能出现的问题并不绝对，部分数据库的同一隔离级别实现仍有不同，因此并不会出现对应的问题。**例如在ANSI SQL STANDARD的标准定义中（如下图所示），在可重读隔离级别下是允许出现幻读，但是PGSQL的可重读隔离级别下，却不会出现幻读：

![ANSI SQL STANDARD](/images/ANSI_SQL_STANDARD.jpg)

### 悲观锁与乐观锁

当多个并发事务在某一隔离级别下同时操纵同一数据时，如果不加以控制，就可能会出现上述的问题。为了解决这些问题，数据库系统提供了两种不同的并发控制机制，分别是悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）。

#### 悲观锁

悲观锁是一种并发控制策略，它基于对数据的悲观估计，认为在事务执行期间其他事务可能会对同一数据进行修改。为了防止这种情况，悲观锁在事务访问数据时会对其进行加锁，以限制其他事务的并发访问，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（只有数据库层提供的锁机制才能真正保证数据访问的排他性，应用层面的加锁机制是无法保证外部系统无法修改数据）。

悲观锁一般分为如下几类：

* 共享锁（Shared Lock）：又称为读锁，允许事务读取一行数据，阻止其他事务获得相同数据集的排他锁，但是允许其他事务获得相同数据集的共享锁，即可以查看但无法修改和删除的一种数据锁，适用于读多写少的场景。

* 排他锁（Exclusive Lock）：又称为写锁，允许事务读取和修改一行数据，阻止其他事务获得相同数据集的共享锁和排他锁（即其他事务无法读取和修改），因此排他锁又称为独占锁。

* 意向锁（Intention Lock）：意向锁是一种表级锁，用于指示一个事务将要在表中的某些数据行上加什么类型的锁。意向锁分为意向共享锁（IS）和意向排他锁（IX），意向共享锁表示一个事务打算在表中的某些数据行上加共享锁，意向排他锁表示一个事务打算在表中的某些数据行上加排他锁。需要特别注意的是：**意向锁是由数据引擎自己维护的，用户无法手动操作意向锁。意向锁之间是互相兼容的！意向锁不会与行级的共享/排他锁互斥！**

    意向锁的作用是为了防止出现死锁和减少开销。当一个事务A要在某表中的某一行数据上加排他锁时（行锁、独占锁），同时事务A会先在表级别上加意向排他锁。如果此时事务B准备在该表上加共享锁（表锁），那么此时事务B要加锁成功，就需要满足此时无事务持有该表的排他锁（表锁）和该表的每一行都无事务持有排他锁（行锁），在没有意向锁的情况下，事务B需要扫描整个表中的每一行才能判断是否满足条件（每一行都需要检测是否有排它锁），而有了意向锁之后，事务B只需要判断是否有事务持有意向排他锁即可，如果没有，则可以加共享锁，如果有，则需要阻塞。

* 更新锁（Update Lock）：更新锁是一种排他锁，它阻止其他事务同时获得相同数据的更新锁或共享锁。更新锁与排他锁是相似的，都是用于防止并发更新问题的悲观锁。主要的区别在于，更新锁的粒度可以更细致，可以应用于某一行而不是整个表。