---
title: 并发编程基础与Java内存模型
date: 2023-06-10 11:47:21
tags: [并发编程, Java内存模型, JMM]
---

## 并发与并行

并发与并行都是多任务处理的方式，他们都可以表示两个或者多个任务一起执行。但并发是指多个任务交替执行，并发是通过CPU时间片轮转的方式实现；而并行是指多个任务同时执行，需要多CPU核心或者多台计算机协同工作才能实现。

## 关于CPU并发分片

CPU并发分片是指在单核CPU上实现多任务处理的一种方式。操作系统会将所有需要执行的任务按照一定的优先级排序，然后将CPU时间分成若干个时间片，每个时间片的长度通常是几十毫秒到几百毫秒不等。然后，操作系统会按照任务的优先级依次将时间片分配给不同的任务，让它们交替执行。当一个任务的时间片用完后，操作系统会将它挂起，然后将CPU时间片分配给下一个任务，以此类推。

通过CPU并发分片，单核CPU可以同时处理多个任务，看起来像是同时执行，但实际上是交替执行的。这种方式可以提高CPU的利用率，让多个任务在单核CPU上得到合理的处理。

## Java内存模型（JMM）

Java内存模型（Java Memory Model，JMM）是Java虚拟机规范中定义的一种抽象的计算机内存模型，它屏蔽了各种硬件和操作系统的内存访问差异，为Java程序在各种平台上的内存访问行为提供了统一的规范。通过这些规则、规范定义了程序中各个变量的访问方式。

jvm运行的程序的实体是线程，而每个线程运行时，都会创建一个工作内存（也叫栈空间），来保存线程所有的私有变量。而JMM内存模型规范中规定所有的变量都存储在主内存中（一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。），而主内存中的变量是所有的线程都可以共享的，而对主内存中的变量进行操作时，必须在线程的工作内存进行操作，首先将主内存的变量copy到工作内存，进行操作后，再将变量刷回到主内存中。所有线程只有通过主内存来进行通信。

<!-- more -->

### JMM的8种内存交互操作

* lock(锁定)：作用于主内存中的变量，一个变量在同一时间只能被一个线程锁定，即把变量标识为线程独占状态。

* read(读取)：作用于主内存变量，表示把一个变量值从主内存传输到线程的工作内存中，以便下一步的 load 操作使用。

* load(载入)：作用于线程的工作内存的变量，表示把 read 操作从主内存中读取的变量值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)。

* use(使用)：作用于线程的工作内存中的变量，表示把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作。

* assign(赋值)：作用于线程的工作内存的变量，表示把执行引擎返回的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作。

* store(存储)：作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便下一步的 write 操作使用。

* write(写入)：作用于主内存的变量，表示把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

* unlock(解锁)：作用于主内存的变量，表示把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

JMM内存交互操作可用下图概括

![JMM内存交互图](/images/JMM.png)

JMM 还规定了以上八种操作需按照如下规则进行：

* 不允许read 和 load、store 和 write 操作之一单独出现，也就是 read 操作后必须 load，store 操作后必须 write。即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。

* 不允许线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。

* 不允许线程将没有 assign 的数据从工作内存同步到主内存。

* 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。也就是对变量实施 use 和 store 操作之前，必须经过 load 和 assign 操作。

* 一个变量同一时间只能有一个线程对其进行 lock 操作。但 lock 操作可以被同一条线程重复执行多次，多次 lock 之后，必须执行相同次数 unlock 才可以解锁。

* 如果对一个变量进行 lock 操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新 load 或 assign 操作初始化变量的值。

* 如果一个变量没有被 lock，就不能对其进行 unlock 操作。也不能 unlock 一个被其他线程锁住的变量。

* 一个线程对一个变量进行 unlock 操作之前，必须先把此变量同步回主内存。

### JMM三大特征

* 原子性：一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程打断。

* 可见性：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

* 有序性：程序执行的顺序按照代码的先后顺序执行。

### 指令重排

为了最大的限度发挥机器性能，jvm根据处理器特性（cpu多级缓存、多核处理器等）适当的对机器指令进行排序，使机器指令能更符合CPU的执行特性，只要程序的最终结果与顺序执行的结果保持一致，则虚拟机就可以进行排序，此过程就叫指令重排序。指令重排遵循as-if-serial语义和happens-before 原则。

#### as-if-serial

as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。

为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。

#### happens-before

* 程序顺序原则：即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。

* 锁规则：解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。

* volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。

* 线程启动规则：线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见

* 传递性 A先于B ，B先于C 那么A必然先于C

* 线程终止规则：线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。

* 线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。

* 对象终结规则：对象的构造函数执行，结束先于finalize()方法。

## 线程不安全

多线程编程最直观的问题就是线程安全问题，当多个线程同时访问共享资源时，可能会出现数据不一致或者其它问题的情况，导致数据出现错误或者不一致的情况。

具体到JMM来看，每个线程都有自己的工作内存（也称之为栈帧，当方法执行完成后，对应的栈帧会被弹出），工作内存中保存了线程局部变量与需要访问的主内存变量的副本，每个线程只能在自己的工作内存中操作变量副本（所以局部变量不存在线程安全问题）。当线程需要访问共享变量时，它会先从主内存中读取变量的值，然后将变量的值赋值到自己的工作内存中。当线程修改变量的值后，需要将修改后的值写回到主内存中，已便其它线程可以看到变量的最新值。由于每个线程都有自己的工作内存，因此多个线程同时访问共享变量时，可能会出现数据不一致的情况。

在多线程编程中，为了避免出现线程不安全的问题，可以使用锁机制控制共享资源的访问，从而避免数据不一致的情况。

## 临界区

多线程编程中，需要对共享变量的访问和操作进行控制。
在Java中，锁机制可以用来控制共享资源的访问，从而避免线程不安全的问题。锁机制可以将多个线程对共享资源的访问串行化，保证在同一时间只有一个线程可以访问共享资源，从而避免了多个线程同时修改共享资源的情况。

在锁机制中，被保护的代码块称为临界区。临界区是指一段代码或方法，在同一时间只能被一个线程执行。当一个线程进入临界区时，它会尝试获取锁，如果锁没有被其它线程占用，那么该线程就可以执行临界区的代码。当线程执行完临界区的代码后释放锁，已便其它线程可以获取锁并执行临界区代码。

## 临界区带来的死锁、饥饿和活锁

Java中的临界区可以保证共享资源的访问是线程安全的，但是也会带来一些问题，例如死锁、饥饿和活锁等。

* 死锁是指两个或多个线程互相持有对方需要的锁，从而导致它们都无法继续执行的情况。例如，线程A持有锁1，等待获取锁2，而线程B持有锁2，等待获取锁1，这样就会导致两个线程都无法继续执行，从而出现死锁的情况。

* 饥饿是指某个线程无法获取所需的资源，从而无法继续执行的情况。例如，如果一个线程一直无法获取所需的锁，那么它就会一直等待，从而无法继续执行，这样就会出现饥饿的情况。

* 活锁是指多个线程在竞争资源时，由于某些原因导致它们一直在重试，但是却无法取得进展的情况。例如，如果多个线程都在等待对方释放锁，那么它们就会一直重试，但是却无法取得进展，这样就会出现活锁的情况。

## 并发级别

由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，大致上可以分为阻塞、无饥饿、无障碍、无锁、无等待几类。

* 阻塞：线程会被阻塞，直到获取到锁或者资源才能继续执行。synchronized关键字和ReentrantLock类就是阻塞的典型代表。

* 无饥饿：线程不会被饥饿，即每个线程都有机会获取锁或者资源。公平锁就是无饥饿的典型代表。

* 无障碍：线程可以自由地读写共享变量，而不需要加锁。无障碍算法就是无障碍的典型代表。

* 无锁 线程不需要加锁，而是通过CAS（Compare and Swap）等机制来实现同步。Atomic类和ConcurrentHashMap类就是无锁的典型代表。

* 无等待 线程不需要等待其他线程释放锁或者资源，而是通过一些算法来实现同步。无等待算法就是无等待的典型代表。
