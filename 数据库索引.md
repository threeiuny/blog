---
title: 数据库索引
date: 2023-09-16 14:47:34
tags: [数据库、索引]
---

## 什么是数据库索引

数据库索引是一种数据结构，用于提高数据库管理系统（DBMS）中数据的检索速度和查询性能。它类似于书籍的目录，允许数据库系统更快速地查找和访问表中的特定行或数据。索引基于一个或多个列中的值创建，并按一定的数据结构组织，以加速数据的查找和过滤。索引的创建或删除不会影响数据本身，然而索引会减慢数据的更新和插入，因为索引也需要维护。

### 为什么需要数据库索引和索引的优缺点

数据库索引是一种数据结构，它能够帮助我们快速的检索数据，提高查询效率。如果没有索引，数据库系统将不得不扫描整个表来查找数据（全表扫描），这将导致查询变慢，尤其是在大型表中。索引可以帮助我们快速定位到我们想要的数据，从而提高查询效率。

索引的优点如下：

* 快速数据检索：通过索引找到所需数据,避免全表扫描。

* 加快分组和排序操作。

* 加速表和表之间的连接。

* 将随机I/O变为顺序I/O。

* 提高并发性能。

索引同时也带来了如下缺点：

* 索引需要占用额外存储空间。

* 更新操作的开销：插入、更新和删除操作可能需要更新索引，这会增加写操作的开销。

* 索引选择和设计的复杂性：不正确的索引选择和设计可能会导致性能下降。

* 索引维护成本：随着数据的不断插入和删除，索引需要定期维护，以保持其性能。

数据库索引是数据库管理系统中非常重要的组成部分，能够显著提高查询性能，但也需要谨慎设计和管理，不正确的索引可能会带来更多的问题。

<!-- more -->

## 磁盘IO与数据预读

在进一步了解数据库索引之前，我们需要先了解一些计算机中的基本的概念，能更好的理解数据库索引的原理。

### 计算机主存（RAM）和外部存储器（磁盘）的区别

计算机中的数据存储器分为主存（RAM）和外部存储器（磁盘）。主存是CPU可以直接访问的存储器，而外部存储器是CPU不能直接访问的存储器，需要通过IO操作才能访问。主存的访问速度比外部存储器快几个数量级，但是主存的容量比外部存储器小很多，且计算机主存是易失存储（断电或重启后，主存中的数据丢失），而外部存储器通常是非易失存储，实际数据库中数据都是存储到外部存储器的（数据和索引分别存储为一个或多个数据文件和索引文件），因此，我们需要在主存和外部存储器之间进行数据交换（即需要进行IO操作才能访问数据）。

### 磁盘IO

机械硬盘读取数据靠的是机械运动（固态硬盘（SSD）通过闪存芯片存储数据，通过电子方式读取和写入数据），当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间，最后便是对读取数据的传输。 所以每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。其中：

* 寻道时间是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下。

* 旋转延迟（旋转延迟 = 1/(2*转速)*60*1000）就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。

* 传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。

那么访问一次磁盘的时间，即一次磁盘IO的时间约在9ms左右，听起来还挺不错的，但要知道一台500-MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。

### 数据预读

计算机科学中有一条著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页的大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

## 查找算法和常用索引的数据结构

索引的原理基于数据结构和算法，在介绍索引的数据结果前，我们需要先介绍一些查询算法，以帮助更好的理解索引是如何提高查询效率的。

### 顺序查找

顺序查找是最简单的一种查找算法，它的原理是从数据集的第一个元素开始，逐个比较每个元素，直到找到目标元素或者遍历完整个数据集。顺序查找的时间复杂度为O(n)，其中n为数据集的大小。

顺序查找算法非常简单，但是它的缺点非常明显，查找效率非常低下，且对于无序队列而言，它无法支持范围查询。

### 二分查找

二分查找是一种高效的查找算法，它的原理是将数据集分成两半，然后递归地在两半中查找，直到找到目标元素或者遍历完整个数据集。二分查找的时间复杂度为O(logn)，其中n为数据集的大小。

由于每次查找都可以将数据集的大小缩小一半，因此二分查找算法效率针对顺序查找而言非常高，但是二分查找算法的缺点也非常明显，它只能用于有序数据集，且对于插入、删除等操作，需要对数据集进行重新排序。

### 哈希查找

哈希查找是一种高效的查找算法，它的原理是通过哈希函数将目标元素映射到一个哈希表中的位置，然后在该位置查找目标元素。哈希查找的时间复杂度为O(1)，其中n为数据集的大小。

哈希查找算法效率非常高，但是它的缺点也非常明显，它只能用于等值查询，且对于范围查询无法支持。

### 二叉搜索树

二叉搜索树（Binary Search Tree）是一种二叉树，它的每个节点包含一个关键字和指向左右子树的指针。对于任意一个节点，它的左子树中的所有节点的关键字都小于它的关键字，而它的右子树中的所有节点的关键字都大于它的关键字。这种结构使得在二叉搜索树中进行查找时，可以通过比较关键字的大小，快速定位目标元素的位置。其数据结果如下所示：

![二叉搜索树](/images/2tree.png)

搜索树的一些基本概念：

* 根节点：树的顶端节点，没有父节点。

* 叶子节点：没有子节点的节点。

* 非叶子（内部）节点：有子节点的节点。

* 节点的度：节点拥有的子树的个数。

* 节点的层次：根节点的层次为1，其他节点的层次等于其父节点的层次加1。

* 树的深度（高度）：树中节点的最大层次。

* 平衡树：任意节点的左右子树的高度差不超过1的二叉搜索树。

二叉搜索树的优势在于：

* 查找效率高：由于二叉搜索树的结构特点，查找效率非常高，时间复杂度为O(log n)，其中n为数据集的大小。

* 插入和删除效率高：二叉搜索树的结构特点也使得插入和删除操作非常高效，时间复杂度也为O(log n)。

* 支持范围查询：由于二叉搜索树的有序性，它支持范围查询非常高效。

* 空间利用率高：二叉搜索树的空间利用率比较高，因为它只需要存储关键字和指针，不需要额外的空间。

二叉搜索树的性能和效率与树的平衡性有关，当二叉搜索树的左右子树的高度差不超过1时，称为平衡树，此时二叉搜索树的性能和效率最高。但是，当二叉搜索树的左右子树的高度差超过1时，称为非平衡树，此时二叉搜索树的性能和效率会下降，甚至会退化为链表。因此，为了保证二叉搜索树的性能和效率，需要保证二叉搜索树的平衡性。

从上面的几种查找算法和数据结果可以明显的看到，使用合适的算法和数据结构将会极大的提高查询效率。数据库索引的本质就是算法的数据结果，它能够帮助我们快速的定位到目标数据，从而提高查询效率。

数据库索引可以使用不同的数据结构实现，每种数据结构都有其独特的优点、特点和作用。以下是一些常见的数据库索引数据结构。

### B-Tree

B树是一个一般化的二叉搜索树（binary search tree），不同于二叉搜索树只能拥有两个子节点，B树一个节点可以拥有2个以上的子节点。一颗经典的B-Tree如下图所示：

![B-Tree](/images/B-Tree.png)

B树的特点如下：

* 自平衡性：B树是一种自平衡树，它通过在插入和删除操作中进行节点的分裂和合并来保持树的平衡。这意味着在插入和删除元素后，B树会自动重新平衡，以确保树的高度保持相对较低，从而保持高效的性能。

* 多路搜索树：B树是一种多路搜索树，每个节点可以拥有多个子节点。这使得B树在高容量数据库中非常有效，因为每个节点可以包含多个键和指向子节点的指针。

* 有序性：B树的节点通常以升序或降序排列，这使得在范围查询和排序操作中非常高效。有序性是B树支持高效点查询和范围查询的重要特征。

* 支持范围查询：由于B树的有序性和多路性质，它非常适合执行范围查询。在B树中，可以快速找到某个范围内的数据，而不需要遍历整个数据集。

* 高效性：一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。

### B+Tree

B+树是B树的一种变体，它与B树的不同之处在于：

* B+树的非叶子节点不保存数据，只用来索引，所有数据都保存在叶子节点中，非叶子节点仅存储索引信息，而B树非叶子节点通常会存储一部分真实数据，这种设计使得B+树具有更好的有序性和范围查询性能，因为非叶子节点的数量相对较少，可以容纳更多的键，从而提供更高效的索引结构。

* B+树的叶子节点之间通过指针相连，且叶子节点按关键字大小顺序存放，每个叶子节点都带有指向下一个叶子节点的指针，这样整棵树的所有叶子节点就构成一个有序链表，而B树的叶子节点之间没有相连。

B+树如下图所示：

![B+Tree](/images/B+tree.png)

### Hash表

哈希表的基本思想是将数据映射到一个固定大小的数组中，通过哈希函数将数据的关键字转换为数组的下标，从而快速定位数据的位置，哈希表是一种高效的数据结构。哈希表的特点如下：

* 高效性：哈希表的插入、查找和删除操作的时间复杂度都为O(1)，即常数时间，因此它的效率非常高。

* 空间利用率高：哈希表的空间利用率比较高，因为它只需要存储关键字和指针，不需要额外的空间。

* 支持动态扩容：哈希表可以动态扩容，当数据集的大小超过哈希表的容量时，可以重新分配更大的数组，并将原有数据重新哈希到新的数组中。

* 不支持范围查询/部分匹配：由于哈希表的数据是无序的，因此它不支持范围查询；由于哈希索引是基于完全匹配的，因此不适合部分匹配或模糊查询。

* 哈希冲突：当多个不同的值映射到相同的哈希桶时，发生哈希冲突。解决哈希冲突通常需要使用开放寻址法（open addressing）或链式哈希表（chained hash table）等方法。

## 索引的分类

数据库索引可以分为很多种，根据不同的分类标准，索引可以分为不同的类型。上文中介绍了数据检索的算法和常用的索引数据结构，由这些数据结构演化除了各种数据库索引，根据索引的数据结构，索引可以分为B-Tree索引、Hash索引等。

除了上述按照数据结构分类的索引外，可能还听过聚集（聚簇）索引、非聚集（非聚簇）索引、唯一索引、复合（联合）索引、主索引、辅助索引等，那么这些索引又是如何分类的呢？

### 聚集索引和非聚集索引

聚集索引（clustered index）是一种数据存储方式，它将数据存储在叶子节点中，其叶子节点包含实际数据行；同时聚集索引决定了数据在磁盘上的物理排列顺序，因此一个表只能有一个聚集索引，通常是主键索引。需要特别注意的是，**聚集索引并不是一种索引类型，而是一种数据存储方式，通常不能直接指定索引类型为聚集索引或非聚集索引，数据库存储引擎通常会根据索引的定义和表的结构自动选择合适的索引类型。虽然B+ Tree也是将数据存储在叶子节点，但B+ Tree是一种通用索引结构，可用于构建各种索引，包括非聚集索引**。

非聚集索引（non-clustered index）则将数据存储在叶子节点以外的地方，叶子节点不包含实际数据，而是包含指向数据行的指针，可以通过非聚集索引快速定位数据行（通常是聚集索引的对应唯一值（主键）），但不决定数据的物理存储布局。一个表可以有多个非聚集索引，用于加速特定查询。

### 主索引和辅助索引

主索引（primary index）是一种特殊的索引，通常与主键（Primary Key）相关联，主索引的叶子节点包含实际数据行，因此可以快速定位数据行，主索引通常是聚集索引。

辅助索引（Secondary Index）是除主索引以外的其他索引，它可以基于表的任意列构建，包括非唯一列。辅助索引通常是非聚簇索引，它的叶子节点包含指向数据行的指针，而不是实际数据行（不绝对，当数据库的数据存储方式为非聚集分布时，辅助索引的叶子节点仍然执行实际的数据行，如下图所示）。辅助索引可以加速特定查询，但是需要进行额外的磁盘I/O操作，因为需要先查找索引，然后再根据指针查找数据行。

![主索引和辅助索引](/images/主索引和辅助索引.jpg)

### 主键索引

主键索引（primary key index）是一种特殊的唯一索引，它要求索引列的值唯一，且不允许空值。主键索引是一种特殊的唯一索引，但是它们通常是聚集索引，因为主键通常是表中的主要查找条件，聚集索引可以提高主键的查找效率。

### 唯一索引

唯一索引（unique index）要求索引列的值唯一，但允许空值。唯一索引可以是聚集索引或非聚集索引，如果索引列是主键，则自动成为聚集索引，否则自动成为非聚集索引。唯一索引可以用于确保数据表中某一列（或多列）的数据不包含重复值，从而维护数据的完整性和唯一性。唯一索引可以进行高效的等值查询。

### 复合（联合）索引

复合索引（Composite Index），也被称为联合索引，是一种包含多个列的索引，通常包括两列或更多列。复合索引的目的是加速多列查询条件的查询操作，并提高数据库性能。

复合索引并不要求查询条件中的所有列都要同时出现，它也可以加速只涉及索引的一部分列的查询条件，只要查询中使用的列是索引的前缀（左侧连续的列）。复合索引的列顺序非常重要。查询中的列顺序应与索引中的列顺序相匹配，如果复合索引包含的列过多或者列的顺序不合理，可能会导致索引失效，从而降低查询效率。

聚簇索引、非聚簇索引、唯一索引、主索引、辅助索引、复合索引等都是根据索引的逻辑结构来进行划分的。索引的逻辑结构是指索引的功能和用途，如是否用于确定表的物理排序，是否要求唯一性等。这些逻辑结构决定了索引在数据库查询优化和数据维护中的作用和效果。理解这些逻辑结构有助于数据库管理员和开发人员更好地设计和管理索引，以满足特定的查询需求和性能优化目标。

## 从B+树查看索引查找过程

从磁盘IO与数据预读那一节我们可以得知，数据查找的过程就是进行磁盘IO，磁盘IO的次数越少，那么查找效率就越高。而索引的数据结构和算法就是为了减少磁盘IO的次数，从而提高查询效率。那么，索引是如何减少磁盘IO的次数的呢？下面通过B+树来查看索引的查找过程。

![B+树查找](/images/b+tree.jpg)

如上图所示，是一颗B+树，为了简化说明搜索过程，对上图的结构进行一些简单的定义。浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

## 创建索引

### 创建索引的通用语法

创建索引的通用语法如下所示：

```sql
-- 通用语法
CREATE [UNIQUE] INDEX index_name
ON table_name (column1, column2, ...);
```

* UNIQUE：可选，表示创建的索引是否唯一，默认为非唯一索引。

* index_name：可选，表示创建的索引的名称，如果不指定名称，系统会自动为索引分配名称。但通常建议指定索引名称，这样可以方便管理索引。

* table_name：必选，表示创建索引的表名。

* column1, column2, ...：必选，表示创建索引的列名，可以指定一个或多个列。

具体不同的数据库系统，创建索引的语法可能会有所不同，但是大同小异，通常都会提供类似的语法，例如MySQL创建索引时，可以指定使用Btree或Hash算法，可以指定索引的存储引擎等。

### 创建索引的示例

创建索引的示例如下所示：

```sql
-- 创建唯一索引
CREATE UNIQUE INDEX idx_user_id ON user (id);
-- 创建非唯一索引
CREATE INDEX idx_user_name ON user (name);
-- 创建联合索引
CREATE INDEX idx_user_name_age ON user (name, age);
-- MySQL创建唯一索引并使用Btree算法
CREATE UNIQUE INDEX idx_user_id ON user (id) USING BTREE;
```
