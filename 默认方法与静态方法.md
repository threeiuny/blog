---
title: 默认方法与静态方法
date: 2023-09-02 14:01:08
tags: [Java8，接口，默认方法，静态方法]
---

## 默认方法与静态方法

在Java8之前，Java程序的接口是将相关方法按照约定组合到一起的方式。实现接口的类必须为接口中定义的每个方法提供一个实现，或者从父类中继承它的实现。但是，一旦类库的设计者需要更新接口，向其中加入新的方法，这种方式就会出现问题。现实情况是，现存的实体类往往不在接口设计者的控制范围之内，这些实体类为了适配新的接口约定也需要进行修改。由于Java 8的API在现存的接口上引入了非常多的新方法，如果依然采用Java 7以前的方式，那么这些新方法就无法被现存的实体类所支持。从Java类库上来看，那么整个Java类库的将无法进行大更新。更新已发布API会导致后向兼容性问题。这就是为什么对现存API的演进，比如官方发布的Java Collection API，会给用户带来麻烦。当然，还有其他方式能够实现对API的改进，但是都不是明智的选择。

为了解决更新已发布API会导致后向兼容性问题，Java 8引入了默认方法的概念，它允许接口中包含具有实现的方法，而不是只能包含抽象方法。这样，当接口的设计者需要向其中加入新的方法时，可以提供一个默认的实现，这样所有的实现类就都可以使用这个默认的实现，而不需要进行修改。默认方法的出现解决了类库设计者面临的如下问题：

* **接口演化问题：** 默认方法允许接口在不破坏现有实现类的情况下进行演化。在Java8之前，一旦一个接口被发布，就不能再添加新的方法，否则会破坏已有的实现类。

* **向后兼容性：** 默认方法提高了接口的向后兼容性，因为现有的类不需要立即实现新增的接口方法。

<!--more-->

### 默认方法

Java对默认方法的定义如下：

* 默认方法是接口中带有方法体且使用`default`关键字定义的方法，在接口中可以定义方法的签名和默认的方法体实现。

* 默认方法允许接口在不破坏已有实现类的前提下添加新的方法。

* 默认方法可以被接口的实现类继承和覆盖，也可以被子接口继承和覆盖。

* 接口包含的方法签名在它的实现类中也可以不提供实现。（实际上，缺失的方法实现会作为接口的一部分由实现类继承（所以命名为默认实现），而无需由实现类提供）

需要注意的是：

* 默认方法是非抽象方法，而函数式接口的定义是只包含一个抽象方法的接口。因此，如果一个接口中包含一个或多个默认方法，且这个接口只有一个抽象方法，那么这个接口仍然是一个函数式接口。

* 默认方法不能重写`java.lang.Object`中的方法。因为`Object`是所有java类的基类。因此，即使我们在接口中将`Object`类方法定义为默认方法，它也将是无用的，因为`Object`类方法将始终被使用（**类优先规则**）。这就是为什么不能有覆盖`Object`类方法的默认方法。

```java
public interface InterfaceA {
    // 默认方法
    default void defaultMethod() {
        System.out.println("InterfaceA default method");
    }
}
```

#### 默认方法与继承问题

默认方法引入了一个新的问题，即多继承冲突。当一个类实现了多个接口，并且这些接口具有相同的默认方法，就会发生冲突（“菱形问题”）。可按照如下规则来解决：

* 类优先规则： 如果一个类继承了另一个类，并且同时实现了两个接口，如果这两个接口都定义了相同的默认方法，那么类继承的方法会覆盖接口中的默认方法。

* 接口优先规则： 如果一个类实现了两个接口，而这两个接口都定义了相同的默认方法，那么类必须在实现中显式指定使用哪个接口的方法，否则会编译错误。

* 显式调用冲突方法： 在类中可以显式调用冲突的方法，通过使用接口名称来区分。

### 静态方法

默认方法已经解决了接口的演化问题，可以在不破坏已有实现类的前提下添加新的方法。那么为什么还需要静态方法？因为同时定义接口以及工具辅助类（companion class）是Java语言常用的一种模式，工具类定义了与接口实例协作的很多静态方法。比如，Collections就是处理Collection对象的辅助类。由于静态方法可以存在于接口内部，我们可以将辅助类的编写移动到接口内部。同时默认方法只能通过实例来调用，而静态方法可以直接通过接口名调用。

Java对静态方法的定义如下：

* 静态方法是接口中带有方法体且使用`static`关键字定义的方法，在接口中可以定义方法的签名和默认的方法体实现。

* 静态方法属于类而不是类的实例。它们通过类名访问，而不是通过对象引用。

* 静态方法可以在不创建类的实例的情况下被调用，因为它们不依赖于对象的状态。

* 静态方法通常用于工具类、辅助方法或不需要实例状态的方法。

静态方法和默认方法一样，是非抽象方法，也不能定义与`java.lang.Object`同名的方法（会提示无法重写`java.lang.Object`中的实例方法），因此如果一个接口中包含一个或多个静态方法，且这个接口只有一个抽象方法，那么这个接口仍然是一个函数式接口。

```java
public interface InterfaceA {
    // 静态方法
    static void staticMethod() {
        System.out.println("InterfaceA static method");
    }
}
```

#### 静态方法与继承问题

静态方法（Static Methods）是类级别的方法，它们属于类而不是类的实例。静态方法的调用不需要创建类的实例，可以通过类名直接调用。因此静态方法的继承与默认方法有着根本上的不同：

* 静态方法是属于类的，而不是实例的，因此它们不会被继承。子类可以定义与父类相同名称的静态方法，但它们并不覆盖父类的静态方法。

* 在使用类名调用静态方法时，如果存在同名的静态方法，将优先调用当前类的静态方法，而不是父类的。

### 默认方法与静态方法的区别

默认方法与静态方法极大的丰富了接口的功能，使得类库设计者在不破坏已有实现类的前提下添加新的方法且减少工具类的编写，但是它们之间还是有着根本的区别：

* 默认方法主要用于接口的 “演化” ，而静态方法主要用于接口的 “工具类” 。

* 静态方法是属于类的，而默认方法是属于接口实例（实现类）的。

* 默认方法存在继承冲突问题，而静态方法不存在继承冲突问题。

* 静态方法可以在类中直接调用，而默认方法必须通过接口的实现类的实例来调用。

```java
public class MyClass {
    public static void staticMethod() {
        System.out.println("This is a static method.");
    }
}

public interface MyInterface {
    // 抽象方法
    void regularMethod(); 

    // 默认方法
    default void defaultMethod() {
        System.out.println("This is a default method.");
    }

    // 静态方法
    static void staticInterfaceMethod() {
        System.out.println("This is a static interface method.");
    }
}

public class Main {
    public static void main(String[] args) {
        // 调用静态方法
        MyClass.staticMethod(); 
        // 调用接口中的静态方法
        MyInterface.staticInterfaceMethod(); 

        MyInterface myInterface = new MyInterface() {
            @Override
            public void regularMethod() {
                System.out.println("This is a regular method.");
            }
        };

        // 调用接口的实例方法
        myInterface.regularMethod(); 
        // 调用接口的默认方法
        myInterface.defaultMethod(); 
    }
}

```
